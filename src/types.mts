/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	"/api/games/self/sentry-config": {
		/** Get sentry config for the game associated with your API key */
		get: operations["sentryConfigOwnGame"];
	};
	"/api/games/{gameId}/sentry-config": {
		/** Get sentry config for a game */
		get: operations["sentryConfig"];
	};
	"/api/games/{gameId}/anti-cheat-config": {
		/** Get anti-cheat config for a game */
		get: operations["antiCheatConfig"];
	};
	"/api/matches/scores": {
		/**
		 * Adds a score for a player
		 * @description The score depends on the game and should be an accumulated score of the user at a given time. Previously submitted scores will be ignored when a player has surrendered or is timed out. Submitting a final score or surrendering will finalize the match for the given player and no subsequent updates can be posted.
		 */
		post: operations["addScore"];
	};
	"/api/user/settings": {
		/**
		 * Updates the settings of a user
		 * @description Used to mirror settings like the mute state of the game back to the platform
		 */
		post: operations["updateSettings"];
	};
	"/api/anybrain/info": {
		/**
		 * Retrieves the user and match id for a given player token
		 * @description To be used by external anti-cheat service anybrain
		 */
		get: operations["playerInfo"];
	};
	"/api/matches/quit": {
		/**
		 * Updates the player in a match with the { quitGame: true } property
		 * @description If the quitGame value is true, the iframe with the game will be closed
		 */
		post: operations["quitMatch"];
	};
	"/api/matches/search": {
		/**
		 * Search a match based on playerToken
		 * @description The playerToken identifies a player in a match. The returned match includes additional information about the requesting player.
		 */
		post: operations["searchMatch"];
	};
	"/api/replays": {
		/** Retrieves a replay by replay id */
		get: operations["getReplay"];
		/**
		 * Adds a replay for a player
		 * @description The replayId is returned as a response and can be used to retrieve the replay. We expect a stringified replay.
		 */
		post: operations["addReplay"];
	};
	"/api/avatar/{playerToken}": {
		/** Retrieves the avatar-url for a player */
		get: operations["avatar"];
	};
}

export type webhooks = Record<string, never>;

export interface components {
	schemas: never;
	responses: {
		/** @description Error response */
		error: {
			content: {
				"application/json": {
					message: string;
					code: string;
					issues?: {
						message: string;
					}[];
				};
			};
		};
	};
	parameters: never;
	requestBodies: never;
	headers: never;
	pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
	/** Get sentry config for the game associated with your API key */
	sentryConfigOwnGame: {
		responses: {
			/** @description Successful response */
			200: {
				content: {
					"application/json": {
						/** Format: uri */
						dsn?: string | null;
						/** @default 0.005 */
						tracesSampleRate?: number;
						/** @default 0.001 */
						replaysSessionSampleRate?: number;
						/** @default 0.1 */
						replaysOnErrorSampleRate?: number;
						/**
						 * @default {
						 *   "captureConsole": {
						 *     "levels": [
						 *       "error",
						 *       "warn"
						 *     ]
						 *   }
						 * }
						 */
						integrations?: {
							captureConsole: {
								levels: string[];
							};
						};
					};
				};
			};
			default: components["responses"]["error"];
		};
	};
	/** Get sentry config for a game */
	sentryConfig: {
		parameters: {
			path: {
				gameId: string;
			};
		};
		responses: {
			/** @description Successful response */
			200: {
				content: {
					"application/json": {
						/** Format: uri */
						dsn?: string | null;
						/** @default 0.005 */
						tracesSampleRate?: number;
						/** @default 0.001 */
						replaysSessionSampleRate?: number;
						/** @default 0.1 */
						replaysOnErrorSampleRate?: number;
						/**
						 * @default {
						 *   "captureConsole": {
						 *     "levels": [
						 *       "error",
						 *       "warn"
						 *     ]
						 *   }
						 * }
						 */
						integrations?: {
							captureConsole: {
								levels: string[];
							};
						};
					};
				};
			};
			default: components["responses"]["error"];
		};
	};
	/** Get anti-cheat config for a game */
	antiCheatConfig: {
		parameters: {
			path: {
				gameId: string;
			};
		};
		responses: {
			/** @description Successful response */
			200: {
				content: {
					"application/json": {
						gameKey: string;
						gameSecret: string;
					};
				};
			};
			default: components["responses"]["error"];
		};
	};
	/**
	 * Adds a score for a player
	 * @description The score depends on the game and should be an accumulated score of the user at a given time. Previously submitted scores will be ignored when a player has surrendered or is timed out. Submitting a final score or surrendering will finalize the match for the given player and no subsequent updates can be posted.
	 */
	addScore: {
		requestBody: {
			content: {
				"application/json": {
					playerToken: string;
					score: number;
					finalSnapshot?: boolean;
					surrender?: boolean;
					/** Format: date-time */
					timestamp: string;
				};
			};
		};
		responses: {
			/** @description Successful response */
			200: {
				content: {
					"application/json": {
						/** @enum {string} */
						success: "true";
					};
				};
			};
			default: components["responses"]["error"];
		};
	};
	/**
	 * Updates the settings of a user
	 * @description Used to mirror settings like the mute state of the game back to the platform
	 */
	updateSettings: {
		requestBody: {
			content: {
				"application/json": {
					playerToken: string;
					mute: boolean;
				};
			};
		};
		responses: {
			/** @description Successful response */
			200: {
				content: {
					"application/json": {
						/** @enum {string} */
						success: "true";
					};
				};
			};
			default: components["responses"]["error"];
		};
	};
	/**
	 * Retrieves the user and match id for a given player token
	 * @description To be used by external anti-cheat service anybrain
	 */
	playerInfo: {
		parameters: {
			query: {
				playerToken: string;
			};
		};
		responses: {
			/** @description Successful response */
			200: {
				content: {
					"application/json": {
						userId: string;
						matchId: string;
					};
				};
			};
			default: components["responses"]["error"];
		};
	};
	/**
	 * Updates the player in a match with the { quitGame: true } property
	 * @description If the quitGame value is true, the iframe with the game will be closed
	 */
	quitMatch: {
		requestBody: {
			content: {
				"application/json": {
					playerToken: string;
				};
			};
		};
		responses: {
			/** @description Successful response */
			200: {
				content: {
					"application/json": {
						/** @enum {string} */
						message: "success";
					};
				};
			};
			default: components["responses"]["error"];
		};
	};
	/**
	 * Search a match based on playerToken
	 * @description The playerToken identifies a player in a match. The returned match includes additional information about the requesting player.
	 */
	searchMatch: {
		requestBody: {
			content: {
				"application/json": {
					matchId?: string;
					playerToken?: string;
				};
			};
		};
		responses: {
			/** @description Successful response */
			200: {
				content: {
					"application/json": {
						id: string;
						player?: {
							userId: string;
							avatar: {
								/** Format: uri */
								url: string;
								/** @enum {string} */
								backgroundColor:
									| "#FFAA7A"
									| "#A9FF94"
									| "#D694FF"
									| "#94BFFF"
									| "#7EFFD1"
									| "#FFDB7E"
									| "#FF7E7E";
							};
							name: string;
							scoreSnapshots: {
								score: number;
								/** Format: date-time */
								timestamp: string;
							}[];
							finalScore?: number;
							replayId?: string;
						};
						players: {
							userId: string;
							avatar: {
								/** Format: uri */
								url: string;
								/** @enum {string} */
								backgroundColor:
									| "#FFAA7A"
									| "#A9FF94"
									| "#D694FF"
									| "#94BFFF"
									| "#7EFFD1"
									| "#FFDB7E"
									| "#FF7E7E";
							};
							name: string;
							scoreSnapshots: {
								score: number;
								/** Format: date-time */
								timestamp: string;
							}[];
							finalScore?: number;
							replayId?: string;
						}[];
						/** @enum {string} */
						status: "running" | "finished" | "cancelled";
						matchTier: {
							playerCount: number;
							/** @enum {string} */
							type: "match" | "tutorial";
						};
						difficulty: ((0 | 1) | 2) | 3;
					};
				};
			};
			default: components["responses"]["error"];
		};
	};
	/** Retrieves a replay by replay id */
	getReplay: {
		parameters: {
			query: {
				matchId: string;
				userId: string;
			};
		};
		responses: {
			/** @description Successful response */
			200: {
				content: {
					"application/json": {
						payload: string;
					};
				};
			};
			default: components["responses"]["error"];
		};
	};
	/**
	 * Adds a replay for a player
	 * @description The replayId is returned as a response and can be used to retrieve the replay. We expect a stringified replay.
	 */
	addReplay: {
		requestBody: {
			content: {
				"application/json": {
					playerToken: string;
					payload: string;
				};
			};
		};
		responses: {
			/** @description Successful response */
			200: {
				content: {
					"application/json": {
						replayId: string;
					};
				};
			};
			default: components["responses"]["error"];
		};
	};
	/** Retrieves the avatar-url for a player */
	avatar: {
		parameters: {
			path: {
				playerToken: string;
			};
		};
		responses: {
			/** @description Successful response */
			200: {
				content: {
					"application/json": {
						/** Format: uri */
						url: string;
						/** @enum {string} */
						backgroundColor:
							| "#FFAA7A"
							| "#A9FF94"
							| "#D694FF"
							| "#94BFFF"
							| "#7EFFD1"
							| "#FFDB7E"
							| "#FF7E7E";
					};
				};
			};
			default: components["responses"]["error"];
		};
	};
}
